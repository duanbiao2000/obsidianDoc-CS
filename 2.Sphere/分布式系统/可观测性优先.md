遵照“定期审查与剪枝”原则，已对笔记 [[可观测性优先]] 进行处理。核心观点和实用信息已保留并优化，冗余及过时内容已剔除。

---

### 精简优化后的笔记：

**核心原则**：可观测性优先（Observability First）是分布式系统设计的基石，要求在设计之初就将数据收集与分析能力融入系统，确保系统状态“透明化”，以支持高效的调试、问题回溯及SLA保障。它与容错性（如失败优先、自愈）紧密结合，前者让系统“抗揍”，后者则让你清楚知道“为何挨揍、如何恢复”。

---

### 可观测性的三大支柱

#### 1. 日志 (Logs)
- **定义**：记录系统离散事件的“日记”，是问题排查的一线索。
- **核心实践**：
    - **结构化**：使用JSON等格式，而非纯文本，便于机器解析。例如：`{timestamp: "...", userId: 123, action: "post_created", status: "success"}`。
    - **集中管理**：通过Fluentd、Logstash等工具将日志统一收集到Elasticsearch或Loki中进行分析。
    - **分级**：明确DEBUG、INFO、WARN、ERROR等级，在不同环境中应用不同策略。
- **价值**：将结构化日志与集中管理结合，可将复杂问题的排查时间从数小时缩短至几分钟。

#### 2. 指标 (Metrics)
- **定义**：系统健康状况的量化数据，是监控系统性能与SLA的“健康报告”。
- **核心实践**：
    - **关键指标**：重点关注请求（QPS、延迟、错误率）、系统（CPU、内存）和业务（用户活跃度、订单量）三类核心指标。
    - **采集与可视化**：使用Prometheus收集指标，通过Grafana创建仪表盘进行可视化监控。
    - **告警**：基于指标设置阈值告警（如“错误率 > 5%”），主动发现问题。
- **价值**：通过指标监控，曾有项目发现80%的延迟源于数据库索引问题，优化后性能翻倍。

#### 3. 追踪 (Traces)
- **定义**：记录单个请求在分布式系统中的完整“旅行轨迹”，串联起跨服务的调用链。
- **核心实践**：
    - **工具应用**：采用Jaeger、Zipkin等工具实现分布式追踪。
    - **传递Trace ID**：为每个请求生成唯一ID（Trace ID），并在跨服务调用时（如通过HTTP Header）全程传递。
    - **瓶颈分析**：通过分析调用链中各环节的耗时，快速定位性能瓶颈。
- **价值**：在微服务架构中，分布式追踪能将跨服务问题的定位时间从数天（依赖日志grep）缩短至几分钟。

---

### 与业务骨架及模块沟通的结合
可观测性使业务骨架变得“可见”，是验证其正确性和稳定性的关键：
- **业务骨架**：日志记录业务操作（如API调用）是否成功，指标衡量系统负载，追踪则定位性能瓶颈。
- **模块沟通**：
    - **接口 (API)**：记录请求参数、响应状态、延迟和错误率。
    - **事件 (Event)**：记录事件的触发与消费状态，追踪事件流转路径。
- **自动化 (IaC)**：通过TOSCA、Terraform或Kubernetes配置，将日志、指标、追踪的收集策略自动化、标准化。

---

### 实施指南
1.  **明确目标**：定义核心业务的SLA，如“API延迟 < 500ms，错误率 < 1%”。
2.  **选择工具栈**：
    - **日志**：Loki / ELK Stack
    - **指标**：Prometheus + Grafana
    - **追踪**：Jaeger / Zipkin
3.  **融入骨架**：在项目模板或核心库中集成日志、指标、追踪的SDK。
    - **前端**：记录用户操作、API请求信息。
    - **后端**：记录API处理逻辑、依赖调用信息。
    - **数据库**：开启慢查询日志。
4.  **验证有效性**：通过故障注入（如使用Toxiproxy模拟网络延迟）测试可观测性系统是否能准确、快速地发现和定位问题。

---
处理时间：2024-07-26