### 1. 为失败而设计，而非为成功 (Design for failure, not for success)
- **核心思想**: 假设系统中任何组件（网络、节点、磁盘）都随时可能发生故障。容错和恢复机制是系统设计的核心部分，而非事后补丁。
- **实践落地**:
    - **冗余**: 在关键路径上部署多个服务实例（如Kubernetes ReplicaSet）。
    - **降级**: 当非核心服务失败时，系统应能优雅降级，保证核心功能可用（如推荐服务失败时，返回通用热门列表）。
    - **自愈**: 利用Kubernetes等编排工具实现服务自动重启、节点自动替换。
    - **补偿事务 (SAGA)**: 对于跨服务事务，设计清晰的回滚和补偿逻辑。

### 2. 最小化对网络的假设 (Minimize assumptions about the network)
- **核心思想**: 永远不要相信网络是可靠的。延迟、丢包、分区是常态。
- **实践落地**:
    - **幂等性**: 确保API和服务可以安全地重试，重复调用不会产生副作用。
    - **异步通信**: 优先使用消息队列（如Kafka, RabbitMQ）进行服务间通信，解耦服务并缓冲网络抖动。
    - **超时与断路器**: 为所有网络调用设置合理的超时，并使用断路器模式防止故障扩散。
    - **分区意识**: 客户端和服务端都应能感知数据分区，将请求路由到正确的节点，避免不必要的跨网络调用。

### 3. 优先选择简单、可预测的失败语义 (Prefer simple, predictable failure semantics)
- **核心思想**: 系统的失败行为应该简单、明确且易于推理，避免复杂的、难以调试的故障模式。
- **实践落地**:
    - **清晰的错误码**: API失败时返回标准、明确的错误码和信息。
    - **原子性或幂等性**: 操作要么完全成功，要么完全失败（回滚），或者可以安全重试。
    - **避免级联失败**: 通过舱壁模式、限流等手段隔离故障，防止单个组件的失败拖垮整个系统。
    - **状态机**: 用明确的状态机来管理复杂流程，使每个状态和转换都是可预测的。

### 4. 让一切皆可观测 (Make everything observable)
- **核心思想**: 如果你无法度量它，你就无法改进它。必须能够深入了解系统内部的运行状态。
- **实践落地**:
    - **日志 (Logs)**: 记录结构化的、包含上下文信息（如Trace ID）的日志。
    - **指标 (Metrics)**: 暴露关键性能指标（QPS、延迟、错误率、资源使用率），并进行监控和告警。
    - **追踪 (Traces)**: 实现分布式追踪，可视化请求在服务间的完整调用链，快速定位瓶颈和故障点。

### 5. 不能扩展，就注定失败 (If it can't scale, it will fail)
- **核心思想**: 系统必须从设计之初就考虑水平扩展能力，以应对业务增长带来的负载压力。
- **实践落地**:
    - **无状态服务**: 尽可能将服务设计为无状态的，以便可以轻松地添加或移除实例。
    - **水平分区 (Sharding)**: 对数据和负载进行分区，使其可以分布在多个节点上。
    - **负载均衡**: 在系统入口和内部各层使用负载均衡器，均匀分散请求。
    - **异步化**: 大量使用异步处理和消息队列，削峰填谷，提高系统的整体吞吐能力。