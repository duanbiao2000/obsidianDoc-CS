---
aliases:
date: 2025-09-11 14:51
tags:
source:
  - https://docs.anthropic.com/zh-CN/docs/build-with-claude/overview
update:
rating:
---

在`SYSTEM_PROMPT`的大文本处理逻辑中，`str_replace_based_edit_tool`和带上下文参数的`grep`是核心工具，二者分别聚焦“文本编辑与精准提取”和“关键词上下文检索”，适配不同场景下的大文本查看需求。以下结合Ubuntu环境特性和实际使用场景，详细拆解它们的用法：

### 一、先明确前提：大文本的“重定向存储”

在使用这两个工具前，需先将bash命令的大输出**重定向到临时文件**（避免刷屏），基础操作格式为：

```bash
# 格式：bash命令 > /tmp/临时文件名.txt（覆盖写入） 或 >> /tmp/临时文件名.txt（追加写入）
# 示例1：查看系统日志（大输出）并存储到临时文件
dmesg > /tmp/system_log.txt

# 示例2：下载大文本文件并存储
curl https://example.com/large_data.txt > /tmp/large_data.txt
```

临时文件路径推荐用`/tmp/`（Ubuntu默认临时目录，重启后自动清理，避免占用空间），文件名可自定义（如`log_temp.txt`、`data_temp.txt`）。

### 二、工具1：`str_replace_based_edit_tool`——文本编辑与精准提取

`str_replace_based_edit_tool`是Anthropic计算机工具集的**自定义文本处理工具**（非系统原生命令），核心能力是“按规则编辑文本、提取关键内容”，支持替换、截取、过滤等操作，尤其适合需要“结构化处理大文本”的场景（如提取特定字段、删除冗余内容）。

#### 核心用法逻辑（工具调用格式）

该工具通过“参数定义操作规则”，需明确3个核心参数：

| 参数名            | 作用                                                    | 示例值                          |
| -------------- | ----------------------------------------------------- | ---------------------------- |
| `file_path`    | 目标临时文件路径（必须是之前重定向存储的文件，如`/tmp/system_log.txt`）        | `/tmp/large_data.txt`        |
| `find_pattern` | 查找规则（支持文本片段、简单通配符，如`"Error: "`、`"2024-*-*"`）          | `"Error: Connection failed"` |
| `replace_with` | 替换/提取规则（若仅提取，可设为`"$0"`（保留匹配内容）；若替换，设为目标文本）            | `"$0"`（提取所有匹配“Error”的行）      |
| （可选）`mode`     | 操作模式（`"extract"`提取匹配内容，`"replace"`替换内容，默认`"extract"`） | `"extract"`                  |

#### 实际场景示例

1. **提取所有错误日志**：\
   若`/tmp/system_log.txt`中有大量系统日志，需提取所有包含“Error”的行：
   ```json
   {
     "name": "str_replace_based_edit_tool",
     "input": {
       "file_path": "/tmp/system_log.txt",
       "find_pattern": "Error:.*",  // 匹配以"Error:"开头的整行（.*表示任意字符）
       "replace_with": "$0",        // $0表示保留匹配到的内容（即提取）
       "mode": "extract"
     }
   }
   ```
   工具输出会直接返回所有匹配的“Error”行，无需查看整个大文件。

2. **替换冗余内容（简化文本）**：\
   若`/tmp/large_data.txt`中有大量“# 注释行”，需删除注释、保留有效内容：
   ```json
   {
     "name": "str_replace_based_edit_tool",
     "input": {
       "file_path": "/tmp/large_data.txt",
       "find_pattern": "^#.*",       // 匹配以"#"开头的注释行（^表示行首）
       "replace_with": "",           // 替换为空（即删除注释行）
       "mode": "replace"
     }
   }
   ```
   操作后，临时文件会被修改（注释行被删除），后续可直接查看简化后的文本。

3. **提取特定字段（结构化数据）**：\
   若`/tmp/user_data.txt`中有“姓名: 张三, 年龄: 25”这类结构化数据，需提取所有“姓名”字段：
   ```json
   {
     "name": "str_replace_based_edit_tool",
     "input": {
       "file_path": "/tmp/user_data.txt",
       "find_pattern": "姓名: (.*?), 年龄:.*",  // (.*?)捕获"姓名:"后的内容（非贪婪匹配）
       "replace_with": "姓名: $1",            // $1表示使用捕获到的内容（即仅保留姓名）
       "mode": "extract"
     }
   }
   ```

### 三、工具2：`grep -n -B <N> -A <M>`——关键词上下文检索

`grep`是Ubuntu**系统原生命令**（无需额外安装），核心作用是“按关键词搜索文本”；而`-n`、`-B`、`-A`是关键参数，用于“显示行号+关键词前后上下文”，适合需要“理解关键词周边内容”的场景（如定位错误原因、查看数据关联信息）。

#### 核心参数解析

| 参数   | 全称          | 作用                    | 示例（`-B 2 -A 3`）                         |
| ---- | ----------- | --------------------- | --------------------------------------- |
| `-n` | line-number | 显示匹配内容的**行号**（方便定位位置） | 输出会带行号，如`123: Error: Connection failed` |
| `-B` | before      | 显示匹配行**之前N行**的内容      | `-B 2`：显示匹配行及它前面2行                      |
| `-A` | after       | 显示匹配行**之后M行**的内容      | `-A 3`：显示匹配行及它后面3行                      |

#### 基础用法格式

```bash
# 格式：grep -n -B <前N行> -A <后M行> "关键词" /tmp/临时文件名.txt
grep -n -B 2 -A 3 "Error" /tmp/system_log.txt
```

#### 实际场景示例

1. **定位错误并查看上下文**：\
   若`/tmp/app_log.txt`中出现“Failed to start”错误，需查看错误前后各2行（分析原因）：
   ```bash
   # 搜索"Failed to start"，显示行号+前2行+后2行
   grep -n -B 2 -A 2 "Failed to start" /tmp/app_log.txt
   ```
   输出示例（带上下文）：
   ```
   45: 2024-05-20 14:30:00: Checking database connection...
   46: 2024-05-20 14:30:01: Connection timeout (10s)
   47: 2024-05-20 14:30:01: Failed to start application
   48: 2024-05-20 14:30:01: Retrying in 5 seconds...
   49: 2024-05-20 14:30:06: Retry failed: Database unreachable
   ```
   从行号45-49可清晰看到：错误原因是“数据库连接超时”，而非其他问题。

2. **搜索关键词并限定上下文长度**：\
   若只需查看关键词前1行、后1行（避免输出过多），可简化参数：
   ```bash
   # 搜索"User login"，显示行号+前1行+后1行
   grep -n -B 1 -A 1 "User login" /tmp/access_log.txt
   ```

3. **模糊匹配关键词**：\
   若关键词可能有拼写变体（如“error”“Error”“ERROR”），可加`-i`参数忽略大小写：
   ```bash
   # 忽略大小写搜索"error"，显示行号+前1行+后1行
   grep -n -i -B 1 -A 1 "error" /tmp/system_log.txt
   ```

### 四、两个工具的场景对比：该用哪个？

| 工具                            | 核心优势                | 适用场景                                                      | 不适用场景                               |
| ----------------------------- | ------------------- | --------------------------------------------------------- | ----------------------------------- |
| `str_replace_based_edit_tool` | 支持编辑（替换/删除）、精准提取    | 1. 提取特定字段（如姓名、ID）；<br>2. 删除冗余内容（注释、空行）；<br>3. 格式化文本（统一格式） | 1. 无需编辑，仅需查看上下文；<br>2. 关键词模糊搜索      |
| `grep -n -B -A`               | 原生命令、快速检索上下文、支持模糊匹配 | 1. 定位关键词并分析周边原因（如错误日志）；<br>2. 快速确认关键词是否存在；<br>3. 查看数据关联信息 | 1. 需要修改文本内容；<br>2. 需提取结构化字段（如仅保留姓名） |

### 总结：大文本处理的完整流程

以“查看系统错误日志”为例，结合两个工具的完整操作链如下：

1. **重定向存储**：`dmesg > /tmp/system_log.txt`（将大日志存入临时文件）；
2. **初步检索**：`grep -n -B 2 -A 2 "Error" /tmp/system_log.txt`（找到错误行及上下文，确认是否需进一步处理）；
3. **精准提取**：若需提取所有错误行，调用`str_replace_based_edit_tool`（参数：`find_pattern="Error:.*"`，`replace_with="$0"`），输出所有错误内容供后续分析。

通过“存储→检索→提取”的流程，可高效处理大文本，避免刷屏且精准获取关键信息。

---

“细粒度工具流式传输”是Anthropic Claude工具使用场景下的优化功能，核心作用是提升大参数传输时的效率，减少延迟，具体可从以下2个关键维度解析：

1. **核心机制：突破传统传输限制**

传统工具调用中，需先对工具参数（如大段文本、复杂指令）进行完整缓冲，再通过JSON格式验证后传输——这个“先存全、再验证、最后传”的流程，在参数体积较大时（如长文档处理、多步骤指令）会产生明显等待延迟。\
而该功能省略了“完整缓冲”和“JSON验证”的前置步骤，直接将工具参数以“细粒度片段”的形式实时流式传输，让工具能边接收参数边启动处理，从流程上缩短了等待时间。

2. **核心价值：适配大参数场景的效率需求**

其主要应用于需要传递大体积参数的工具交互场景（如网页获取后的长内容分析、多步骤代码执行指令等），通过减少传输环节的“中间等待”，让Claude与外部工具的协作更流畅，避免因参数处理流程导致的响应卡顿。


