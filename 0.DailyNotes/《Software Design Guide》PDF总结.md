---
aliases:
date: 2025-09-06 13:54
tags:
source:
  - https://github.com/ArjanCodes/examples/blob/main/2025/standard/02_pathlib.py
update:
rating:
---

# 《Software Design Guide》PDF总结

## 一、指南概述

该指南由ArjanCodes撰写，旨在帮助开发者解决软件开发中面临的复杂问题，避免代码混乱，提供了一套7步计划，助力开发者持续设计出易于维护的优质软件。无论是开发新软件还是为现有软件添加新功能，指南都强调记录设计思路的重要性，这不仅能防止遗漏关键信息，还能锻炼设计思维能力，且提供了结构化的框架来组织思路。

## 二、7步软件设计计划

### （一）明确开发内容（DEFINE WHAT YOU’RE BUILDING）

1. **核心问题**
   - 明确软件应用或功能具体是什么。
   - 确定目标用户群体。
   - 明晰软件要解决的问题。
   - 规划软件的工作方式。
   - 梳理涉及的主要概念及其相互关系。
2. **关键方法与理念**
   - 可采用领域驱动设计（Domain-Driven Design），其核心是基于领域模型构建早期粗略原型，而非先花大量时间设计完美方案再实施，而是让设计与实施并行。在分析领域进行软件设计时，尽早开展某种形式的实施工作，既能了解软件技术架构，发现影响设计的技术限制，同时领域分析也可能为技术工作带来新见解。
   - 要勇于删减内容（即“提炼模型”），简化设计，聚焦软件核心功能，且最佳的重构方式就是删除代码。
   - 采用“先放大再缩小”的思路：先从宏观层面广泛思考软件及其所需内容（放大），经验丰富的开发者会在此概念阶段投入更多时间；之后再聚焦细节（缩小），确定优先开发内容、可延迟构建部分、简易任务，分析开发顺序对工作复杂度的影响，以及先构建哪些部分能加快测试、提升后续开发效率。从业务角度看，这一步也相当于定义最小可行产品（MVP），以最小工作量测试产品实用性及商业潜力。

### （二）设计用户体验（DESIGN THE USER EXPERIENCE）

1. **核心问题**
   - 梳理主要用户故事，包括顺畅流程和备选流程。
   - 若为现有软件添加新功能，分析该功能对整体界面结构的影响，如菜单、导航等组织方式是否有较大变化。
   - 可在用户故事中附上UI原型或线框图，明确流程呈现形式。
2. **关键经验与提醒**
   - 设计软件时需牢记是为用户服务，设计需符合用户认知。有时需增加额外概念以阐明系统工作方式，且最通用的解决方案未必是对用户最佳的方案。
   - 以作者过往为学校和大学软件平台添加分析仪表板的经历为例，曾设计通用且功能强大的方案，允许客户自定义仪表板和编写Python代码实现分析，但因客户无需复杂分析而无人使用，由此强调设计前需确认用户需求，避免开发无用功能。
   - 构建用户界面耗时较长，且界面变更需编写文档、与现有用户沟通，还可能引入后续需解决的漏洞，因此设计时需谨慎。

### （三）了解技术需求（UNDERSTAND THE TECHNICAL NEEDS）

1. **核心问题**
   - 明确开发者开发软件或新功能需了解的技术细节。
   - 确定是否需向数据库添加新表及表的字段。
   - 规划软件技术实现方式，明确重要算法或库。
   - 设计整体架构，确定所需类及用于建模概念和关系的设计模式。
   - 明确构建软件或功能所需的第三方软件。
2. **实用工具与编码建议**
   - 可使用UML绘制新增主要类及其与系统其他部分的关系，作者推荐使用基于文本的Mermaid绘图工具，因其在GitHub、VS Code等开发者常用工具中支持渲染。
   - 编码时可遵循以下原则简化代码维护：
     - 优先使用函数而非类，在Python、Rust等支持函数式编程的语言中，函数式代码通常更简洁，仅在函数参数过多或需对象表示数据时引入类。
     - 保持模块、函数、方法及类的实例变量数量简洁，便于代码阅读和测试。
     - 分离对象创建与使用过程，不在函数内创建对象后立即调用方法，而是在函数外创建对象并作为参数传入，提升代码可测试性。
     - 运用抽象概念，如Python中的ABCs或Protocols、Rust中的Traits，减少依赖，降低代码修改时的出错概率。
   - 需在此步骤描述系统需正确处理的特定边缘情况，如网络连接错误时的应对措施。

### （四）实施测试与安全措施（IMPLEMENT TESTING AND SECURITY MEASURES）

1. **核心问题**
   - 确定单元测试的特定覆盖率目标。
   - 明确所需测试类型，如单元测试、回归测试、端到端测试等。
   - 若为新功能，分析其对应用其他领域可能产生的副作用。
   - 确定软件发布前需实施的安全检查措施。
   - 若为新功能，评估其对软件安全性的影响，判断发布前是否需进行安全审计。
2. **测试重要性与实践建议**
   - 测试不仅能帮助发现漏洞、生成更可靠代码，更重要的是，设计和编写易于测试的代码能培养开发者的测试思维，默认考虑边缘情况，自动组织代码以处理边缘情况，并设计接口、类和方法引导用户遵循顺畅流程。
   - 举例说明：编写从数据库按特定角色获取用户的函数时，使用枚举（Enum）替代字符串参数指定角色，可借助类型系统自动处理无效角色的边缘情况，减少额外代码和测试工作，这也体现了强类型检查语言能早期发现问题的优势。
   - 确保代码易于维护，可制定编码标准并使用辅助工具，如Python中的自动格式化工具Black或Ruff，且避免过度追求复杂代码。同时对比Python和Rust的特点：Python类型和错误处理灵活，入门快但长期开发需开发者明确代码使用场景；Rust学习曲线陡峭，初期编写代码需频繁应对编译器问题，但能强制开发者在发布前处理边缘情况，生成更稳健软件。
   - 编写测试时需考虑开发过程中的代码变更，无需盲目追求100%测试覆盖率，应先完成功能基础版本以评估其是否符合需求，且需做好代码可能被舍弃的准备，不执着于已编写的代码。

### （五）规划工作（PLAN THE WORK）

1. **核心问题**
   - 估算开发软件或功能所需时间。
   - 分解开发步骤并估算每个步骤的耗时。
   - 确定开发里程碑及其先后顺序。
   - 判断是否需编写迁移脚本。
   - 识别主要风险因素及可行的替代方案。
   - 明确开发必需部分和可后续实施部分（即“完成定义”）。
2. **工作规划建议**
   - 新手开发者难以准确估算开发时间，需通过多次实践提升。估算时可先识别主要风险因素，例如为应用添加与Microsoft Teams集成的功能，核心风险在于集成代码开发（部分需在Teams应用商店操作），而非应用内相关用户界面搭建。风险因素越多，需为意外情况预留越多时间。

### （六）识别连锁反应（IDENTIFY RIPPLE EFFECTS）

1. **核心问题**
   - 明确除设计和实施功能外还需完成的工作。
   - 确定需更新的文档内容。
   - 判断是否需向现有用户传达相关信息。
   - 分析是否有其他外部系统需更新，如支付提供商、电子邮件营销系统、销售系统等。
2. **重要提醒**
   - 技术人员易忽视软件开发之外的工作，而软件发布、确保用户顺利使用等相关流程和任务耗时较多。即使这些任务不重要或不由自己负责，在软件设计阶段提前考虑，可避免最后时刻出现问题。对于用户量大的软件，考虑软件变更的连锁反应至关重要，这也是大型软件公司开发进度看似缓慢的原因，因其需投入大量时间处理连锁反应。

### （七）了解更广泛背景（UNDERSTAND THE BROADER CONTEXT）

1. **核心问题**
   - 分析当前设计的局限性。
   - 思考未来可能的功能扩展方向。
   - 考虑其他因素，如预算限制等。
2. **实用思路**
   - 设计软件时可纳入一些“大胆设想”（如“软件若能实现X功能会很棒”），这能培养开放思维，可能带来新见解，甚至在开发过程中获得灵感实现这些设想。
   - 了解当前设计的局限性有助于长期改进软件，为未来软件修改提供明确起点。

## 三、其他重要说明

1. 指南未深入讨论设计模式是有意为之，作者认为设计优质软件的关键阶段是理解待解决的问题，这是许多开发者易跳过但至关重要的一步，后续将详细探讨设计模式和原则。
2. 作者提供了多种获取更多信息和反馈的渠道，包括个人网站（<https://www.arjancodes.com）、YouTube频道（https://www.youtube.com/@arjancodes）、LinkedIn账号（https://www.linkedin.com/company/arjancodes）、X账号（https://x.com/arjancodes）和Discord频道（https://discord.arjan.codes），欢迎读者反馈指南使用体验，可通过邮件联系作者。>

---

这句话的核心是**在支持函数式编程的语言中，优先选择更轻量的函数组织代码，仅在必要时才用类**，背后是“避免过度设计”和“匹配语言特性”的逻辑，具体解析如下：

1. **函数的核心优势：简洁、低开销**

Python、Rust等语言天然支持函数式特性（如Python的lambda、高阶函数，Rust的闭包、函数作为参数传递），函数本身是“无状态”的——不依赖自身外部的持久数据，仅通过输入参数计算输出，代码逻辑直接、行数少，且不需要像类那样定义构造器、维护实例属性，减少了冗余代码和内存开销（比如不需要创建实例对象）。

例如：计算两个数的平方和，用函数`def sum_square(a, b): return a**2 + b**2`一句话实现，若强行用类，反而需要定义`class Calculator: def __init__(self, a, b): ... def sum_square(self): ...`，逻辑冗余。

2. **类的适用场景：解决“复杂状态/参数”问题**

类的核心价值是**封装“数据+操作”**，当满足以下两种场景时才需要引入：

- 场景1：函数参数过多，难以维护。比如一个“用户信息处理”逻辑，若用函数需传递`name, age, phone, email, address`等10+参数，调用和修改时容易出错；而用类封装成`class User`，将这些参数作为实例属性，函数（方法）只需通过`self`访问，代码更清晰。

- 场景2：需要用“对象”表示现实/抽象实体。比如表示“汽车”，它不仅有`品牌、排量`等数据，还有`启动、刹车`等操作，这些数据和操作天然属于一个整体，用类`class Car`封装，能体现逻辑关联性，也便于后续扩展（如继承实现“电动车”子类）。

3. **本质：匹配语言特性，拒绝“为用类而用类”**

Python、Rust虽支持面向对象（OOP），但并非所有场景都需要OOP的复杂性。函数式编程的“无状态、纯函数”特性，在处理简单计算、数据转换（如列表过滤、映射）等场景时，比类更贴合语言设计；只有当需要管理“有状态数据”或“复杂逻辑聚合”时，类的封装、继承优势才会凸显——本质是让代码结构“按需选择”，而非拘泥于某一种范式。

---

你提到的这种做法是软件开发中提升代码可测试性和灵活性的重要原则，核心思想是**依赖注入（Dependency Injection）**，通过分离对象创建与使用，带来以下明显优势：

### 问题：函数内直接创建对象的弊端

假设我们有一个发送邮件的函数，直接在函数内部创建邮件客户端对象：

```python

def send_notification(message):

# 函数内创建对象并立即使用

client = EmailClient("smtp.example.com", 587)

client.send(message) # 直接调用方法

```

这种写法的问题在于：

1. **测试困难**：无法替换为测试用的模拟对象（Mock），必须依赖真实的邮件服务器才能测试

2. **耦合紧密**：函数与`EmailClient`的创建逻辑强绑定，若更换邮件服务提供商，需修改函数内部

3. **灵活性差**：无法动态切换对象的配置（如不同环境的服务器地址）

### 优化：外部创建对象，作为参数传入

```python

def send_notification(client, message):

# 仅使用对象，不关心其创建方式

client.send(message)

# 在函数外部创建对象

prod_client = EmailClient("smtp.example.com", 587)

test_client = MockEmailClient() # 测试用的模拟对象

# 使用时传入不同对象

send_notification(prod_client, "正式消息") # 生产环境

send_notification(test_client, "测试消息") # 测试环境

```

### 核心优势

1. **可测试性提升**：

测试时可传入模拟对象（如记录是否调用过`send`方法，无需发送真实邮件），隔离外部依赖，使单元测试更稳定、快速。

2. **降低耦合度**：

函数只依赖对象的接口（如`send`方法），不关心对象的具体实现和创建细节，符合**依赖倒置原则**（依赖抽象而非具体）。

3. **灵活性增强**：

同一函数可接收不同配置或不同类型的对象（只要实现了相同接口），轻松适配不同场景（如生产/测试环境切换）。

4. **职责单一化**：

函数专注于“使用对象完成业务逻辑”，对象创建由外部负责，符合**单一职责原则**，代码结构更清晰。

这种模式在框架设计（如Spring的依赖注入）、测试框架（如pytest的fixture）中被广泛应用，是编写可维护代码的基础实践之一。

---

好的，以下是完整的代码示例，全部显示在正文中以便复制：

### 1. 使用字符串参数的实现（存在隐患）

```python

# 字符串参数方式 - 存在潜在问题

def get_users_by_role(db_connection, role):

"""从数据库获取特定角色的用户"""

# 必须手动验证角色有效性

valid_roles = ["admin", "user", "guest"]

if role not in valid_roles:

raise ValueError(f"无效角色: {role}")

# 执行数据库查询

query = f"SELECT * FROM users WHERE role = '{role}'"

return db_connection.execute(query).fetchall()

# 调用示例（容易出错）

try:

# 正确调用

admins = get_users_by_role(db, "admin")

# 潜在错误：拼写错误不会被提前发现

editors = get_users_by_role(db, "edtior") # 运行时才会报错

except ValueError as e:

print(e)

```

### 2. 使用枚举(Enum)的实现（更优设计）

```python

from enum import Enum

from typing import List

# 定义角色枚举

class Role(Enum):

ADMIN = "admin"

USER = "user"

GUEST = "guest"

def get_users_by_role(db_connection, role: Role) -> List[dict]:

"""从数据库获取特定角色的用户（使用枚举参数）"""

# 无需手动验证角色有效性（枚举本身就是约束）

query = f"SELECT * FROM users WHERE role = '{role.value}'"

return db_connection.execute(query).fetchall()

# 调用示例（更安全）

if __name__ == "__main__":

# 正确调用 - 只能从枚举中选择有效值

admins = get_users_by_role(db, Role.ADMIN)

# 以下代码在IDE/编译阶段就会报错（无需运行测试）

# editors = get_users_by_role(db, "edtior") # 类型不匹配

# managers = get_users_by_role(db, Role.MANAGER) # 枚举中不存在该值

```

这两种实现方式可以直接复制使用，清晰展示了使用枚举如何通过设计提升代码的可靠性并减少测试工作。
