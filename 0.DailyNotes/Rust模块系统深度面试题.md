# Rust 模块系统深度面试题

## 一、项目结构与设计

### Workspace vs 单一 Package #card
**问题**：与单一 Package 相比，使用 Workspace 组织 Rust 项目有哪些主要优势？
**答案**：
1.  **依赖统一**：整个工作区共享一个 `Cargo.lock` 文件，确保所有成员包使用完全一致的依赖版本。
2.  **构建高效**：共享一个 `target` 输出目录，使得编译缓存可以被所有成员包复用，加快增量编译。
3.  **代码共享**：可以轻松地在不同成员包之间共享代码，而无需发布到 crates.io。
4.  **管理便捷**：可以通过顶层命令（如 `cargo test --workspace`）统一管理所有成员包。

在哪些场景下应优先选择使用 Workspace？::
1.  {微服务架构}：每个服务作为一个独立的包。
2.  {大型库与应用分离}：项目包含一个核心库和一个或多个使用该库的二进制应用（如 Web 服务、CLI 工具）。
3.  {代码分层清晰}：将领域层、应用层、基础设施层拆分为独立的包。

### API 门面模式
在设计 Rust 库时，什么是“API 门面”（API Façade）模式？::这是一种设计模式，通过在库的顶层（如 `lib.rs`）为库提供一个单一、统一的入口点，从而隐藏内部复杂的子系统和模块结构。

如何使用 `pub use` 来构建 API 门面？::在库的根文件（`lib.rs`）中，使用 `pub use` 将内部深层模块中的公共项（如结构体、函数）重新导出到库的顶层。

构建 API 门面的主要好处是什么？::
1.  **API与实现解耦**：内部模块结构可以随意重构，只要更新 `pub use` 路径，外部用户的代码就不受影响。
2.  **提升易用性**：用户只需从库的顶层导入所需项，而不必关心复杂的内部路径。
3.  **明确API边界**：清晰地定义了什么是库的公共 API，什么是内部实现细节。

为什么说直接暴露库复杂的内部模块结构是一种反模式？::因为它造成了{紧耦合}。用户的代码直接依赖于库的内部实现细节（目录结构），一旦库进行重构，所有用户的代码都可能编译失败，这使得库变得脆弱且难以维护。

### 模块系统与分层架构
如何将分层架构（如应用层、领域层、基础设施层）映射到 Rust 的目录结构？::通常将每一层作为一个父模块（即一个目录），例如 `src/application/`、`src/domain/`、`src/infrastructure/`。

在分层架构中，Rust 的模块系统如何**强制执行**单向依赖规则？::
1.  **`use`语句控制**：通过代码审查，禁止在低层模块（如 `domain`）中 `use` 高层模块（如 `infrastructure`）。
2.  **隐私规则与依赖倒置**：在低层（如 `domain`）定义公共的 Trait（接口），在高层（如 `infrastructure`）实现这些 Trait。这样，依赖关系被反转，如果有人试图在 `domain` 中直接使用 `infrastructure` 的具体实现，会因违反 `use` 规则或隐私限制而导致编译失败。

### 循环依赖
诊断和解决模块间循环依赖的策略有哪些？::
1.  **提取共享模型**：将循环依赖中涉及的核心数据模型提取到一个独立的、更底层的模块（如 `models` 或 `domain`），让原来的模块都去依赖这个新模块。
2.  **依赖倒置原则**：在一个模块中定义 Trait（接口），在另一个模块中实现它，从而打破直接的相互依赖，转而依赖于抽象。

## 二、隐私与可见性

### `pub` 可见性修饰符
`pub`、`pub(crate)` 和 `pub(in path)` 三种可见性修饰符的精确含义是什么？::
-   **`pub`**：{全局可见}。任何引入其父模块的代码都可以访问。
-   **`pub(crate)`**：{Crate 内部可见}。项可以在当前 `crate` 的任何地方被访问，但对外部不可见。
-   **`pub(in path)`**：{指定路径内可见}。将项的可见性限制在给定的模块路径内。

如何让一个模块中的函数只被其**直接父模块**访问？::使用 `pub(super)` 修饰符。

## 三、`use` 语句与代码风格

### `use` 惯例
导入函数和导入类型（Struct/Enum）的惯用实践有什么不同？::
-   **函数**：通常导入其{父模块}，调用时使用 `module::function()` 的形式。
-   **类型**：通常导入其{完整路径}，可以直接使用类型名，如 `HashMap`。

支持“函数导入父模块，类型导入完整路径”这一惯例的理由是什么？::
-   对于{函数}，保留父模块前缀（如 `fs::read_to_string`）可以清晰地表明函数的来源，避免命名空间混淆。
-   对于{类型}，其使用场景（如 `HashMap::new()`）通常已经包含了类型信息，直接导入类型名可以使代码更简洁而不失清晰度。

## 四、模块文件组织

### 模块文件组织演进 #card
**问题**：Rust 2015 版和 2018 版在处理包含子模块的模块时，文件组织方式有何不同？
**答案**：
-   **2015 版**：如果模块 `foo` 有子模块，其内容必须放在 `foo/mod.rs` 文件中。`mod.rs` 是一个特殊的“魔术”文件名。
-   **2018 版及以后**：惯例是将模块 `foo` 的内容放在 `foo.rs` 文件中，其子模块放在 `foo/` 目录下。`foo.rs` 成为了模块的根，消除了 `mod.rs` 的特殊地位。

Rust 2018 版对模块文件组织的简化带来了什么好处？::
1.  **消除歧义**：避免了在编辑器中同时打开多个名为 `mod.rs` 的文件造成的混淆。
2.  **提高可发现性**：模块 `foo` 的代码总是在名为 `foo.rs` 的文件中，更加直观。
3.  **结构更清晰**：降低了新手的学习曲线。

## 五、测试与模块系统

### 单元测试与集成测试
`#[cfg(test)]` 属性的作用是什么？::它是一个{条件编译}属性，被标记的代码块只在执行 `cargo test` 时才会被编译，在常规构建中会被忽略。

在单元测试模块 `mod tests` 中，为什么经常需要 `use super::*;`？::因为 `mod tests` 是一个{子模块}，`use super::*;` 用于将其父模块中的所有项（包括需要测试的私有项）导入到测试模块的作用域中。

内联单元测试和集成测试的核心区别是什么？::
-   **可见性**：{单元测试}可以访问被测模块中的**私有项**（白盒测试），而{集成测试}只能访问库的**公共 API**（黑盒测试）。
-   **测试目标**：{单元测试}关注单个模块或函数的内部逻辑，{集成测试}关注整个库的对外契约和多模块交互。