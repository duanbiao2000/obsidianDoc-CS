---
date: 2025-08-23 14:49
tags:
  - 重构
---
## 自测试代码
当然可以！你提到的这句话：

> **“绝大多数情况下，如果想要重构，我得先有可以自测试的代码”**\
> —— 来自 Martin Fowler 的 *Refactoring*（重构），标记为 `[mf-stc]`

这不仅是经验之谈，更是现代高效开发团队的**生存法则**。

---

## ✅ 核心概念：什么是“可以自测试的代码”？

> **“自测试代码”（Self-Testing Code）** 是指：\
> 每一段业务逻辑都有对应的**自动化测试覆盖**，一旦代码变更，能通过运行测试快速反馈是否破坏了原有功能。

换句话说：\
🟢 **你改代码不害怕，因为测试会告诉你有没有出错。**

---

## 🚀 现代高效开发团队如何实践“自测试代码”？

以下是 **4 个真实、高效的团队实例**，来自不同规模和技术栈，但都遵循同一原则：

---

### 💼 实例 1：Spotify（敏捷小队 + 测试驱动开发）

#### 📌 场景：

Spotify 的“Squad”（小队）模式下，每个团队独立负责一个功能模块（如播放器、推荐引擎）。

#### 🔧 如何实现“自测试代码”：

- **TDD（测试驱动开发）**：先写测试，再写实现代码。
- **单元测试全覆盖**：使用 Jest（前端）、JUnit（后端）确保核心逻辑 90%+ 覆盖率。
- **CI/CD 流水线强制检查**：任何 PR 必须通过所有测试才能合并。
- **重构常态化**：每周都有“技术债清理日”，团队放心重构，因为测试是“安全网”。

#### 🎯 成果：

- 每天数千次部署
- 新人加入后 3 天内就能安全修改核心代码

> ✅ **没有测试 = 不能合并代码**

---

### 💼 实例 2：GitHub（开源协作 + 自动化测试网）

#### 📌 场景：

GitHub 自身就是全球最大代码平台，其产品开发必须高度可靠。

#### 🔧 如何实现“自测试代码”：

- 所有 Pull Request 必须附带测试用例（否则 CI 失败）
- 使用 **RSpec（Ruby） + Jest（TypeScript） + Cypress（E2E）** 构建多层测试网
- **“测试即文档”**：测试文件本身就是行为规范
- 重构时，先更新测试 → 再改实现 → 确保行为不变

#### 🎯 成果：

- 支持 7000 万开发者使用
- 核心功能（如 Actions、Pages）可频繁重构而不中断服务

> ✅ **每一次重构，都是在测试保护下进行的演进**

---

### 💼 实例 3：Shopify（电商平台 + 大规模重构）

#### 📌 场景：

Shopify 拥有数百万商户，系统复杂度极高，曾进行“从单体到微服务”的大重构。

#### 🔧 如何实现“自测试代码”：

- **“测试金字塔”实践**：
  - 大量单元测试（快速反馈）
  - 中等集成测试（验证模块交互）
  - 少量端到端测试（关键路径）
- 使用 **Ruby on Rails + Minitest + WebMock** 模拟外部依赖
- 在重构旧支付逻辑时，**先写测试捕捉现有行为**，再逐步替换实现
- 使用 **Feature Flag** 控制新旧逻辑切换，测试环境全程验证

#### 🎯 成果：

- 成功将 10 年历史的单体应用拆分为 100+ 服务
- 零重大线上事故（得益于测试保障）

> ✅ **没有测试，不敢动老代码；有了测试，重构就像换零件**

---

### 💼 实例 4：Netflix（高可用系统 + 持续交付）

#### 📌 场景：

Netflix 需要 7×24 小时不间断服务，任何故障都会影响千万用户。

#### 🔧 如何实现“自测试代码”：

- **“Chaos Engineering” 前提就是有强大测试基础**
- 所有服务必须提供：
  - 单元测试（JUnit/TestNG）
  - 集成测试（Docker + Testcontainers）
  - 合同测试（Pact）
  - 性能测试（Gatling）
- 使用 **Spinnaker** 实现自动化部署，每一步都依赖测试通过
- 重构推荐算法时，A/B 测试 + 自动化回归测试双保险

#### 🎯 成果：

- 每天数千次部署
- 可以在生产环境“故意制造故障”来测试系统韧性（混沌工程）

> ✅ **测试不是成本，是让系统敢变、能变的资本**

---

## 🧩 总结：高效团队的共同特征

| 特征           | 说明              |
| ------------ | --------------- |
| ✅ 测试先行       | TDD 或至少“测试伴随开发” |
| ✅ CI/CD 强制执行 | 不通过测试，代码无法上线    |
| ✅ 高覆盖率       | 核心模块 > 80% 覆盖率  |
| ✅ 重构常态化      | 每周/每月都有技术债清理    |
| ✅ 测试即文档      | 通过测试理解业务逻辑      |
| ✅ 安全感        | 开发者敢改老代码，不怕出问题  |

---

## 🛠️ 你可以立即行动的 5 个步骤

| 步骤  | 行动                                     |
| --- | -------------------------------------- |
| 1️⃣ | 给你最常维护的模块写第一个单元测试（哪怕只测一个函数）            |
| 2️⃣ | 在 CI 中加入 `npm test` 或 `pytest`，失败就阻止部署 |
| 3️⃣ | 用 `coverage` 工具查看测试覆盖率，设定目标（如 70%）     |
| 4️⃣ | 重构前，先写测试“冻结”当前行为（[mf-stc] 的精髓）         |
| 5️⃣ | 把测试当作“重构的保险”——没有它，就不动手                 |

---

## 🎯 一句话总结

> **“可以自测试的代码”不是理想，而是现代开发的底线。**\
> 所有高效团队都知道：\
> 🔒 **测试是重构的安全网，\
> 🚀 没有测试，就没有真正的敏捷与持续交付。**

---

📌 **记住 Martin Fowler 的原话**：

> “If you want to refactor, you must have a solid suite of tests. It’s that simple.”\
> —— Martin Fowler, *Refactoring: Improving the Design of Existing Code*

> 你不需要一开始就完美，但你必须**从第一行代码开始，就为它写测试**。

---

