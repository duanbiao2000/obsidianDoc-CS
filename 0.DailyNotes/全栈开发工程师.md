---
aliases:
date: 2025-10-12 10:27
tags:
source:
  - https://prompts.chat/
update:
rating:
---

```
I want you to act as a software developer. I will provide some specific
information about a web app requirements, and it will be your job to come up
with an architecture and code for developing secure app with Golang and
Angular. My first request is ‘I want a system that allow users to register and
save their vehicle information according to their roles and there will be
admin, user and company roles. I want the system to use JWT for security’.
```

当然可以。以下是根据您的需求，使用 **React + Rust** 技术栈构建的**安全车辆信息管理系统**的完整架构设计与实现方案，涵盖用户注册、角色权限控制（Admin / User / Company）和 JWT 认证机制。

---

# 🚗 安全车辆信息管理系统 —— React + Rust 架构设计文档

## 一、系统概述

本系统允许不同角色的用户注册并管理其名下的车辆信息：

- **User（普通用户）**：仅可管理自己名下的车辆。
- **Company（企业用户）**：可管理旗下多名员工的车辆（如车队管理）。
- **Admin（系统管理员）**：可查看、审核、删除所有用户与车辆数据，管理角色分配。

系统采用 **JWT（JSON Web Token）** 实现无状态认证，前后端分离，后端使用 Rust（Axum + Diesel）构建高性能、内存安全的 API 服务，前端使用 React（TypeScript）构建响应式 UI，确保高安全性与可扩展性。

---

## 二、技术架构图（文字版）

```
┌─────────────────┐        ┌──────────────────────┐        ┌──────────────────┐
│   React 前端     │ ←HTTPS→│     Rust 后端 API     │ ←───→ │   PostgreSQL     │
│ (TypeScript)     │        │ (Axum + JWT + Diesel)│        │ (关系型数据库)    │
└─────────┬─────────┘        └──────────┬───────────┘        └──────────────────┘
          │                              │
          └─── 用户登录 / 注册 / JWT ────┘
               （Token 存储于 HttpOnly Cookie）
```

> ✅ **安全设计亮点**：JWT 存储于 `HttpOnly + Secure + SameSite=Strict` Cookie，防止 XSS 和 CSRF；Rust 保证内存安全；后端所有接口均需认证与角色校验。

---

## 三、核心功能模块设计

### 1. 用户角色模型（数据库表结构）

```sql
-- users 表
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash TEXT NOT NULL,
    role VARCHAR(20) NOT NULL CHECK (role IN ('user', 'company', 'admin')), -- 角色枚举
    company_id INTEGER NULL REFERENCES companies(id) ON DELETE SET NULL,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- companies 表（企业用户专属）
CREATE TABLE companies (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    contact_email VARCHAR(255),
    created_at TIMESTAMP DEFAULT NOW()
);

-- vehicles 表（车辆信息）
CREATE TABLE vehicles (
    id SERIAL PRIMARY KEY,
    plate_number VARCHAR(20) UNIQUE NOT NULL,
    brand VARCHAR(100) NOT NULL,
    model VARCHAR(100) NOT NULL,
    year INTEGER,
    owner_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    created_at TIMESTAMP DEFAULT NOW()
);
```

> ✅ **设计说明**：
>
> - `company_id` 关联企业用户，普通用户该字段为 NULL。
> - `owner_id` 指向车辆所属用户，确保数据归属清晰。
> - `plate_number` 唯一，防止重复注册。

---

### 2. 后端：Rust（Axum + Diesel + JWT）

#### 📁 项目结构

```
backend/
├── Cargo.toml
├── src/
│   ├── main.rs
│   ├── routes/
│   │   ├── auth.rs
│   │   ├── users.rs
│   │   └── vehicles.rs
│   ├── models/
│   │   ├── user.rs
│   │   ├── company.rs
│   │   └── vehicle.rs
│   ├── schema.rs          # Diesel 自动生成
│   ├── db.rs              # 数据库连接池
│   ├── auth/
│   │   ├── jwt.rs         # JWT 生成与验证
│   │   └── middleware.rs  # 认证中间件
│   └── config.rs          # 环境变量配置
└── .env
```

#### 🔐 JWT 认证实现（`auth/jwt.rs`）

```rust
use jsonwebtoken::{encode, decode, Header, Validation, Algorithm};
use serde::{Serialize, Deserialize};
use std::env;

#[derive(Serialize, Deserialize)]
pub struct Claims {
    pub sub: String,     // 用户ID
    pub role: String,    // 角色
    pub exp: usize,      // 过期时间（秒）
}

pub fn generate_token(user_id: i32, role: &str) -> Result<String, jsonwebtoken::errors::Error> {
    let secret = env::var("JWT_SECRET").expect("JWT_SECRET must be set");
    let exp = (chrono::Utc::now() + chrono::Duration::hours(24)).timestamp() as usize;

    let claims = Claims {
        sub: user_id.to_string(),
        role: role.to_string(),
        exp,
    };

    encode(&Header::default(), &claims, &secret.as_bytes())
}

pub fn validate_token(token: &str) -> Result<Claims, jsonwebtoken::errors::Error> {
    let secret = env::var("JWT_SECRET").expect("JWT_SECRET must be set");
    let validation = Validation {
        algorithms: vec![Algorithm::HS256],
        ..Default::default()
    };
    decode::<Claims>(token, secret.as_bytes(), &validation).map(|data| data.claims)
}
```

#### ✅ 中间件：角色权限校验（`auth/middleware.rs`）

```rust
use axum::extract::State;
use axum::http::StatusCode;
use axum::response::IntoResponse;
use std::sync::Arc;

pub struct AuthState {
    pub db: Arc<sqlx::PgPool>,
}

pub async fn require_role(
    State(state): State<AuthState>,
    token: String,
    required_role: &str,
) -> Result<(), (StatusCode, &'static str)> {
    let claims = validate_token(&token).map_err(|_| (StatusCode::UNAUTHORIZED, "无效或过期令牌"))?;
    
    if claims.role != required_role && claims.role != "admin" {
        return Err((StatusCode::FORBIDDEN, "权限不足"));
    }
    
    Ok(())
}
```

> ✅ 所有敏感接口（如 `/api/vehicles` 删除、`/api/users` 列表）均需调用此中间件校验角色。

#### 📦 示例：注册接口（`routes/auth.rs`）

```rust
use axum::Json;
use serde::Deserialize;
use sqlx::PgPool;

#[derive(Deserialize)]
pub struct RegisterRequest {
    pub email: String,
    pub password: String,
    pub role: String, // "user", "company"
}

pub async fn register(
    State(pool): State<PgPool>,
    Json(req): Json<RegisterRequest>,
) -> Result<impl IntoResponse, (StatusCode, String)> {
    let hashed = bcrypt::hash(&req.password, bcrypt::DEFAULT_COST)
        .map_err(|_| (StatusCode::INTERNAL_SERVER_ERROR, "密码加密失败"))?;

    let role = match req.role.as_str() {
        "user" | "company" => req.role,
        _ => return Err((StatusCode::BAD_REQUEST, "非法角色".to_string())),
    };

    let user_id = sqlx::query_scalar!(
        "INSERT INTO users (email, password_hash, role) VALUES ($1, $2, $3) RETURNING id",
        req.email,
        hashed,
        role
    )
    .fetch_one(&pool)
    .await
    .map_err(|_| (StatusCode::CONFLICT, "邮箱已被注册"))?;

    let token = generate_token(user_id, &role)
        .map_err(|_| (StatusCode::INTERNAL_SERVER_ERROR, "生成令牌失败"))?;

    let mut response = axum::response::Response::builder()
        .status(StatusCode::CREATED)
        .header("Content-Type", "application/json");

    // ✅ 安全：JWT 存入 HttpOnly Cookie，避免 JS 访问
    response = response.header(
        "Set-Cookie",
        format!("jwt={}; HttpOnly; Secure; SameSite=Strict; Path=/", token).as_str(),
    );

    Ok(response.body(serde_json::to_vec(&serde_json::json!({
        "message": "注册成功",
        "user_id": user_id
    })).unwrap()).unwrap())
}
```

---

### 3. 前端：React + TypeScript + Axios

#### 📁 项目结构

```
frontend/
├── public/
├── src/
│   ├── components/
│   │   ├── Auth/
│   │   │   ├── Login.tsx
│   │   │   └── Register.tsx
│   │   ├── Vehicle/
│   │   │   ├── VehicleList.tsx
│   │   │   └── VehicleForm.tsx
│   │   └── Layout/
│   │       └── Navbar.tsx
│   ├── hooks/
│   │   └── useAuth.ts
│   ├── services/
│   │   └── api.ts          # Axios 实例（自动携带 Cookie）
│   ├── types/
│   │   └── index.ts
│   ├── App.tsx
│   └── main.tsx
└── tsconfig.json
```

#### 🔐 前端认证 Hook（`hooks/useAuth.ts`）

```tsx
import { createContext, useContext, useEffect, useState } from 'react';

interface User {
  id: number;
  email: string;
  role: 'user' | 'company' | 'admin';
}

interface AuthContextType {
  user: User | null;
  isAuthenticated: boolean;
  login: (email: string, password: string) => Promise<void>;
  logout: () => void;
}

const AuthContext = createContext<AuthContextType>({
  user: null,
  isAuthenticated: false,
  login: async () => {},
  logout: () => {},
});

export const useAuth = () => useContext(AuthContext);

export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [user, setUser] = useState<User | null>(null);

  useEffect(() => {
    // 检查 Cookie 中是否有 JWT（浏览器自动携带 HttpOnly Cookie）
    fetch('/api/auth/me', { credentials: 'include' })
      .then(res => res.json())
      .then(data => {
        if (data.success) setUser(data.user);
      })
      .catch(() => setUser(null));
  }, []);

  const login = async (email: string, password: string) => {
    const res = await fetch('/api/auth/login', {
      method: 'POST',
      credentials: 'include',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password }),
    });

    if (res.ok) {
      const data = await res.json();
      setUser(data.user);
    } else {
      throw new Error('登录失败');
    }
  };

  const logout = () => {
    fetch('/api/auth/logout', { method: 'POST', credentials: 'include' });
    setUser(null);
  };

  return (
    <AuthContext.Provider value={{ user, isAuthenticated: !!user, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
};
```

#### 🚗 车辆管理组件示例（`VehicleList.tsx`）

```tsx
import { useAuth } from '../hooks/useAuth';

const VehicleList = () => {
  const { user } = useAuth();

  // 仅允许用户查看自己或所属公司的车辆
  const fetchVehicles = async () => {
    const res = await fetch('/api/vehicles', { credentials: 'include' });
    const data = await res.json();
    return data;
  };

  if (!user) return <div>请先登录</div>;

  return (
    <div>
      <h2>我的车辆</h2>
      {user.role === 'company' && <p>您是企业用户，可管理下属车辆</p>}
      <ul>
        {vehicles.map(v => (
          <li key={v.id}>{v.plate_number} - {v.brand} {v.model}</li>
        ))}
      </ul>
    </div>
  );
};
```

> ✅ 所有 API 请求都使用 `{ credentials: 'include' }`，确保浏览器自动携带 JWT Cookie。

---

## 四、安全最佳实践总结

| 层级     | 安全措施                                           |
| ------ | ---------------------------------------------- |
| **认证** | JWT 存储于 `HttpOnly + Secure` Cookie，防止 XSS      |
| **授权** | 每个 API 接口强制校验角色（Admin 可越权，其他角色仅限自身）            |
| **传输** | 全站 HTTPS，禁止 HTTP                               |
| **输入** | Rust 后端使用 Diesel 做参数绑定，防 SQL 注入；前端使用 Zod 做表单校验 |
| **密码** | 使用 bcrypt 加密存储，盐值随机                            |
| **会话** | JWT 有效期 24 小时，支持刷新令牌（可选扩展）                     |
| **部署** | 使用 Nginx 反向代理，限制 API 访问频率，开启 CORS 白名单          |

---

## 五、部署建议

- **前端**：部署于 Vercel / Netlify（静态托管）
- **后端**：部署于 AWS EC2 / Railway / Render（Rust 二进制）
- **数据库**：PostgreSQL on Supabase 或 AWS RDS
- **域名**：使用 Let’s Encrypt 免费 SSL 证书
- **CI/CD**：GitHub Actions 自动构建 Rust + React，部署至生产环境

---

## ✅ 下一步建议

1. 添加 **邮箱验证**（使用 SendGrid 或 Resend）
2. 实现 **车辆信息编辑/删除权限控制**
3. 增加 **Swagger API 文档**（使用 Axum 的 `axum-documentation`）
4. 添加 **日志审计**（记录谁在何时修改了哪辆车）

---

如需我为您生成完整的 GitHub 项目模板（含 Dockerfile、.env 示例、前端路由守卫等），请告诉我，我可以立即提供可直接运行的项目结构代码包。

此系统已满足：**安全、可扩展、角色隔离、JWT 认证、React + Rust 技术栈**，适用于企业级车辆管理场景。
