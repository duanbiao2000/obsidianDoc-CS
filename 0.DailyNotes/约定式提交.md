
[[约定式提交]]是一种用于规范化Git提交消息的轻量级约定。它通过在提交消息中添加简单、明确的前缀，为提交历史赋予了机器和人类都易于理解的结构。

#### 提交消息结构

其基本格式如下：
```
<类型>[可选的作用域]: <描述>
```
*   **类型 (Type)**: 必须是下方定义的关键词之一，用于说明提交的类别。
*   **作用域 (Scope)**: 可选，用于说明本次修改影响的范围（如模块、组件名）。
*   **描述 (Description)**: 对本次提交的简洁说明。

#### 提交类型与含义

| 类型 (Type)    | 含义             | 示例                          |
| :----------- | :------------- | :-------------------------- |
| **feat**     | 新增功能 (Feature) | `feat(用户模块): 添加用户注册功能`      |
| **fix**      | 修复Bug          | `fix: 修复按钮标签的拼写错误`          |
| **docs**     | 仅修改文档          | `docs: 更新安装指南`              |
| **style**    | 不影响代码含义的格式修改   | `style: 根据代码风格指南格式化代码`      |
| **refactor** | 代码重构           | `refactor: 简化工具函数中的算法`      |
| **perf**     | 性能优化           | `perf: 优化搜索性能`              |
| **test**     | 添加或更正测试        | `test: 为工具函数添加单元测试`         |
| **build**    | 构建系统或外部依赖变更    | `build: 更新npm依赖`            |
| **ci**       | 持续集成配置变更       | `ci: 在Travis构建中添加Node.js版本` |
| **chore**    | 构建流程、辅助工具等变动   | `chore: 更新npm脚本`            |
| **revert**   | 回滚到上一个提交       | `revert: 切换到语义化版本`          |

#### 优势

*   **清晰的提交历史**: 任何人都可以通过浏览提交历史快速理解每个提交的目的。
*   **自动化版本控制**: 可以根据提交类型（如`feat`对应次版本，`fix`对应补丁版本）自动生成语义化版本号。
*   **自动生成变更日志 (Changelog)**: 工具可以基于提交历史自动生成结构清晰、内容丰富的变更日志。

---

Conventional Commits（约定式提交）是一种规范化的 Git 提交信息格式规范，旨在使提交历史提交历史更清晰、更易读，同时便于自动化版本管理和生成变更日志。

其核心规范如下：

### 基本格式
```
<类型>[可选 作用域]: <描述>

[可选 正文]

[可选 脚注]
```

### 主要组成部分
1. **类型（type）**：描述提交的性质，常用类型包括：
   - `feat`：新功能
   - `fix`：修复 bug
   - `docs`：仅文档变更
   - `style`：不影响代码含义的变更（如格式调整）
   - `refactor`：既不修复 bug 也不添加功能的代码重构
   - `perf`：改进性能的代码变更
   - `test`：添加或修正测试代码
   - `build`：影响构建系统或外部依赖的变更
   - `ci`：修改 CI 配置文件和脚本
   - `chore`：其他不修改 src 或 test 的变更

2. **作用域（scope）**（可选）：指定提交影响的模块或组件，如 `feat(auth)` 表示认证模块的新功能。

3. **描述（description）**：简洁的提交摘要，不超过 50 个字符，首字母小写，结尾不加句号。

4. **正文（body）**（可选）：详细描述提交内容，可分多行，解释"为什么做这个变更"而非"怎么做的"。

5. **脚注（footer）**（可选）：用于关闭 issue 或标记破坏性变更：
   - 关闭 issue：`Closes #123`
   - 破坏性变更：以 `BREAKING CHANGE:` 开头

### 示例
```
feat(login): add social login options

Support login with Google and Facebook accounts.
Users can now choose between email/password and social login.

Closes #456
```

```
fix(api): correct error handling for empty requests

BREAKING CHANGE: The API now returns 400 instead of 500 for empty requests.
```

### 优势
- 提供清晰的提交历史，便于团队协作和代码审查
- 自动化生成版本号（基于语义化版本）和 CHANGELOG
- 便于工具分析提交内容，实现自动化流程

许多工具支持约定式提交，如 Commitlint（校验提交信息）、Standard Version（自动版本管理）等。

### 4. 提交消息规范

为了保持 Git 历史的清晰和一致性，请遵循以下提交消息规范：

- **提交前审查:** 在每次提交前，请务必审查暂存的更改：
    
    - 查看简要统计：`git --no-pager diff --staged --stat`
    - 快速浏览详细更改（如果需要）：`git --no-pager diff --staged`
- **描述性主题:** 编写描述性主题，清晰地解释更改内容和原因。避免使用“chore: commit local work”等占位符。
    
- **Conventional Commits:** 优先使用 Conventional Commits，并可选择添加范围：
    
    - `feat(tui/history): show exit code and duration for Exec cells`
    - `fix(core/exec): handle SIGINT in on_exec_command_begin to avoid orphaned child`
    - `docs(agents): clarify commit-message expectations`
- **主题长度:** 主题应保持在 72 个字符以内。如果需要理由或上下文，可添加简短的正文。
    
- **动词时态:** 使用祈使句、现在时态：“add”、“fix”、“update”（而不是“added”、“fixes”）。
    
- **合并提交:** 对于合并提交，跳过自定义前缀（例如 `merge(main<-origin/main):`）。使用清晰的主题，例如 `Merge origin/main: <what changed and how conflicts were resolved>`。
---

要理解“Responses API”，首先需要明确它是**Anthropic 公司为其大语言模型（如 Claude）提供的一套应用程序编程接口（API）** ——简单来说，就是开发者可以通过代码调用 Claude 模型能力的“通道”，而“Responses API”是这套接口中专门用于**获取模型响应结果（包括推理过程、最终回答等）** 的核心模块。


### 1. 先明确基础概念：API 与大模型 API
在理解“Responses API”前，先铺垫两个核心概念：
- **API（应用程序编程接口）**：是不同软件之间“通信”的规则和工具。比如你用手机APP查天气，APP就是通过“天气API”从气象局服务器获取数据的；
- **大模型 API**：像 Claude、GPT 这类大语言模型，普通用户通过网页界面使用，但开发者若想把模型能力嵌入自己的产品（如企业客服系统、智能文档工具），就需要通过“大模型 API”用代码调用——而“Responses API”就是 Anthropic 为 Claude 设计的、专门负责“返回模型响应”的 API 模块。


### 2. Responses API 的核心作用
Anthropic 的 Claude API 通常包含“发送请求”和“接收响应”两个关键环节，**Responses API 就是负责“接收响应”的部分**：  
当开发者通过代码向 Claude 发送指令（比如“总结一份文档”“分析一个问题”）后，Responses API 会将 Claude 的处理结果（包括最终回答、推理过程、额外元数据等）以结构化格式（如 JSON）返回给开发者，方便开发者将结果集成到自己的产品中。

举个实际场景例子：  
如果某公司开发了一款“智能合同分析工具”，背后调用了 Claude 模型，其流程就是：
1. 工具将用户上传的合同文本通过“请求API”发送给 Claude；
2. Claude 分析合同中的风险条款、关键条款；
3. **Responses API 将 Claude 的分析结果（比如“风险点1：XX条款存在歧义”“推理过程：根据XX法律条文，该条款可能导致XX后果”）返回给工具**；
4. 工具将结果整理成用户易懂的界面展示出来。


### 3. 为什么“model_reasoning_summary”是 Responses API 的专属参数？
你提到的 `model_reasoning_summary`（控制推理摘要详细程度），本质是**开发者通过 Responses API 调用 Claude 时，可以额外设置的“响应格式控制参数”** ——因为只有通过 API 调用（而非普通网页界面），开发者才需要自定义“模型返回的内容是否包含推理摘要、摘要多详细”（比如企业客服场景可能需要“concise 简洁推理”，而法律分析场景可能需要“detailed 详细推理”）。

如果是普通用户在 Claude 网页端直接对话，模型会默认输出推理和回答，无法自定义这个参数；但通过 Responses API 调用时，开发者可以根据自己的产品需求，用代码设置 `model_reasoning_summary: "detailed"` 或 `"none"`，灵活控制返回结果的格式。


### 总结
- **Responses API 是什么**：Anthropic 为 Claude 模型提供的、用于“返回模型响应结果”的编程接口模块，是开发者调用 Claude 能力的核心“输出通道”；
- **核心价值**：让开发者能通过代码获取 Claude 的结构化响应（包括回答、推理过程等），并自定义响应格式（如你提到的推理摘要详细程度），从而将 Claude 能力嵌入到各类产品中；
- **使用场景**：仅面向开发者（非普通用户），常见于企业工具、智能应用、自动化系统等场景。